# ТЗ: Оптимизатор производственных цепочек (Heroes)

## Цель
Автоматически подбирать минимальный по количеству состав «нижележащих» зданий, который обеспечивает заданный выпуск конечного продукта (ресурса) за один производственный цикл, **без дефицита** промежуточных ресурсов и с учётом доступных уровней зданий на текущем этапе игры.

## Термины и сущности БД
Схема **heroes** (Postgres):

- **culture** — культура/фракция (например, `CHINA`).
- **cycle** — производственный цикл: `MIN30`/`H1`/`H2` (число минут в поле `minutes`).
- **resource** — вид ресурса (`MOTH_COCOON`, `RICE`, `THREAD`, `SILK`, и т.д.).
- **building_type** — тип здания (`MOTH_GLADE`, `RICE_FARM`, …), привязан к `culture`.
- **building** — конкретный **уровень** определённого `building_type` (уникальность по `(type, level)`).  
- **flow** — поток ресурса для тройки `(building, cycle, resource)`:
  - `quantity > 0` — здание **производит** ресурс за один цикл;
  - `quantity < 0` — здание **потребляет** ресурс за один цикл.

## Постановка задачи
Задано:
- целевой продукт (ресурс) **R\***,
- здание‑производитель **B\*** типа `T*` уровня `L*` (количество `N*`), 
- культура `C`, цикл `Y`,
- карта ограничений доступных уровней `max_level_by_type`: словарь `тип -> максимально разрешённый уровень` (0 — полностью запретить тип).

Найти:
- натуральные количества `x_{t,l}` для всех остальных зданий (тип `t`, уровень `l`), такие что:
  1. Баланс по **каждому потребляемому** ресурсу соблюдён за цикл: суммарное производство минус потребление не отрицательно.
  2. Заданное количество `N*` зданий `B*` закреплено (не оптимизируется).
  3. (Опционально) общий лимит на число «нижних» зданий.

Цель оптимизации:
- **минимизировать** суммарное число «нижних» зданий `Σ x_{t,l}`, а затем
- **минимизировать** суммарный профицит промежуточных ресурсов (вторая, маленькая компонента цели).

## Математическая формулировка (MILP)
Переменные: `x_b ∈ Z_{≥0}` — количество зданий (по `building.id`); `s_r ≥ 0` — профицит по ресурсу `r`.

Пусть `f_{b,r}` — чистый поток ресурса `r` у здания `b` за цикл (из `heroes.flow`).  
Фиксированная часть от целевого здания `B*` с количеством `N*`: `F_r = N* · f_{B*,r}`.

Ограничения баланса для каждого **потребляемого** ресурса `r`:
```
Σ_b f_{b,r} · x_b + F_r − s_r = 0
```
Целевая функция:
```
minimize   M · Σ_b x_b  +  Σ_r s_r         (M — большое число, например 1e6)
```

## API оптимизатора (Python)
Модуль `heroes_optimizer.py` предоставляет класс `ProductionOptimizer`:

```python
opt = ProductionOptimizer(PgRepository(<dsn?>))

result = opt.optimize_for_target_resource(
    culture_code='CHINA',
    cycle_code='H1',
    target_resource_code='SILK',
    producer_building_type_code='SILK_WORKSHOP',
    producer_level=3,
    producer_count=1,
    max_level_by_type={'MOTH_GLADE':3, 'RICE_FARM':2, 'THREAD_PROCESSOR':2, 'SILK_WORKSHOP':3},
    extra_limit_total_buildings=None,   # опционально
)
```

Возвращаемое значение `OptimizationResult` состоит из:
- `plan: {building_type_code: {level: count}}` — подбор «нижних» зданий;
- `resource_surplus: {resource_code: float}` — профицит ресурсов за цикл;
- `total_aux_buildings: int` — всего нижних зданий;
- `status: str` — статус решателя (`Optimal` — успех).

Есть также метод `optimize_for_target_building(...)`, если уже известен тип/уровень/кол‑во целевого здания и не требуется указывать ресурс.

## Ограничения уровней
Словарь `max_level_by_type` управляет доступностью уровней:
- значение **0** — тип здания запрещён целиком;
- положительное значение — разрешены уровни `≤ max_level`;
- целевое здание допускается **поверх** этих ограничений (чтобы можно было считать гипотезы развития).

## Расширения
- учёт «стоимости слотов»/редкости: заменить цель `Σ x_b` на `Σ w_b · x_b` (весы задать в БД);
- ограничения по суммарным слотам/энергии/населению: добавить линейное ограничение;
- поддержка нескольких площадок сразу: добавить ещё одно фиксированное здание в модель;
- планирование на разные циклы (30/60/120 минут): просто заполнять `heroes.flow` для циклов `MIN30` и `H2`.

## Производительность и индексирование
- Запросы используют фильтрацию по `culture_id` и `cycle_id`.  
- Рекомендуемые индексы: `flow(building_id, cycle_id)`, `building(type, level)`, `building_type(culture_id)`.  
- В текущем DDL есть `ix_flow_res (resource_id)`, можно добавить `create index ix_flow_build_cycle on heroes.flow(building_id, cycle_id);`.

## Поведение ошибок
- Неизвестная культура/цикл/тип/уровень → `ValueError`.
- Недостижимость балансов (нет производителей нужного ресурса) → `RuntimeError`.
- Неоптимальный статус решателя → `RuntimeError` с текстом статуса.

## Пример (данные из скрипта DML)
Цель: 1 × `SILK_WORKSHOP L3` (культура `CHINA`, цикл `H1`).  
Ограничения: `MOTH_GLADE≤3`, `RICE_FARM≤2`, `THREAD_PROCESSOR≤2`, `SILK_WORKSHOP≤3`.

Ожидаемый план нижних зданий (может отличаться при изменении коэффициентов):
- `MOTH_GLADE L3` — 3 шт
- `RICE_FARM L2` — 4 шт
- `THREAD_PROCESSOR L2` — 3 шт  
Профицит: кокон ≈ 369/цикл, рис ≈ 110/цикл, нить ≈ 110/цикл.

## Развёртывание
1. Применить ваш DDL, затем `heroes_init_china.sql` (DML).  
2. Установить зависимости: `pip install psycopg2-binary pulp`.  
3. Задать `DATABASE_URL` или передать `dsn` в `PgRepository`.  
4. Запустить пример из `__main__` или импортировать класс в консольных скриптах.

## План фронтенда (на будущее)
- форма выбора: культура, цикл, целевой ресурс и здание‑производитель, уровень, количество;
- таблица ограничения уровней по типам (редактируемая пользователем);
- кнопка «Подобрать» → вызов оптимизатора, рендер плана и профицитов;
- пресеты уровней «Текущий прогресс игрока» для быстрого ввода.
